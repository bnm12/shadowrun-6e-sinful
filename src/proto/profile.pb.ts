// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: src/proto/profile.proto
/* eslint-disable */

import type { ByteSource, PartialDeep } from "protoscript";
import * as protoscript from "protoscript";

//========================================//
//                 Types                  //
//========================================//

/**
 * Enum for gender options
 */
export type Gender =
  | "GENDER_UNSPECIFIED"
  | "GENDER_MALE"
  | "GENDER_FEMALE"
  | "GENDER_DIVERSE";

/**
 * Enum for SIN quality levels
 */
export type SinQuality =
  | "SIN_QUALITY_UNSPECIFIED"
  | "SIN_QUALITY_LEVEL_1"
  | "SIN_QUALITY_LEVEL_2"
  | "SIN_QUALITY_LEVEL_3"
  | "SIN_QUALITY_LEVEL_4"
  | "SIN_QUALITY_LEVEL_5"
  | "SIN_QUALITY_LEVEL_6";

/**
 * Enum for blood types
 */
export type BloodType =
  | "BLOOD_TYPE_UNSPECIFIED"
  | "BLOOD_TYPE_A_POSITIVE"
  | "BLOOD_TYPE_A_NEGATIVE"
  | "BLOOD_TYPE_B_POSITIVE"
  | "BLOOD_TYPE_B_NEGATIVE"
  | "BLOOD_TYPE_AB_POSITIVE"
  | "BLOOD_TYPE_AB_NEGATIVE"
  | "BLOOD_TYPE_O_POSITIVE"
  | "BLOOD_TYPE_O_NEGATIVE";

/**
 * Level 1: Basic identity check - just confirms SIN exists
 */
export interface SinLevel1 {
  photo: string;
}

/**
 * Level 2: Core identity fields
 */
export interface SinLevel2 {
  name: string;
  birthdate: string;
  birthplace: string;
  gender: Gender;
  metatype: string;
}

/**
 * Level 3: All printed SIN information
 */
export interface SinLevel3 {
  fullName: string;
  address: string;
  city: string;
  country: string;
  nationality: string;
  occupation: string;
  datalinks: string[];
}

/**
 * Level 4: Physical biometrics
 */
export interface SinLevel4 {
  fingerprintHash: string;
  retinalHash: string;
  voiceHash: string;
  height: number;
  weight: number;
  eyeColor: string;
  hairColor: string;
  skinTone: string;
}

/**
 * Level 5: Deep background data
 */
export interface SinLevel5 {
  employer: string;
  employerAddress: string;
  travelStamps: string[];
  affiliationCodes: string[];
  educationRecords: string[];
  residenceHistory: string[];
}

/**
 * Level 6: Genetic markers
 */
export interface SinLevel6 {
  bloodType: BloodType;
  dnaSequenceHash: string;
  geneticMarkers: string[];
  medicalAlertCodes: string;
}

/**
 * Main profile data structure
 */
export interface ProfileData {
  /**
   * Core SIN metadata
   */
  sinId: string;
  active: boolean;
  sinQuality: SinQuality;
  /**
   * Licenses (separate from SIN data)
   */
  licenses: Record<string, ProfileData.Licenses["value"] | undefined>;
  /**
   * Layered SIN data by verification level
   */
  level1?: SinLevel1 | null | undefined;
  level2?: SinLevel2 | null | undefined;
  level3?: SinLevel3 | null | undefined;
  level4?: SinLevel4 | null | undefined;
  level5?: SinLevel5 | null | undefined;
  level6?: SinLevel6 | null | undefined;
  /**
   * Random seeds for generating consistent fake data
   */
  baseSeed: number;
  biometricSeed: number;
  backgroundSeed: number;
}

export declare namespace ProfileData {
  interface Licenses {
    key: string;
    value: SinQuality;
  }
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Gender = {
  GENDER_UNSPECIFIED: "GENDER_UNSPECIFIED",
  GENDER_MALE: "GENDER_MALE",
  GENDER_FEMALE: "GENDER_FEMALE",
  GENDER_DIVERSE: "GENDER_DIVERSE",
  /**
   * @private
   */
  _fromInt: function (i: number): Gender {
    switch (i) {
      case 0: {
        return "GENDER_UNSPECIFIED";
      }
      case 1: {
        return "GENDER_MALE";
      }
      case 2: {
        return "GENDER_FEMALE";
      }
      case 3: {
        return "GENDER_DIVERSE";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as Gender;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: Gender): number {
    switch (i) {
      case "GENDER_UNSPECIFIED": {
        return 0;
      }
      case "GENDER_MALE": {
        return 1;
      }
      case "GENDER_FEMALE": {
        return 2;
      }
      case "GENDER_DIVERSE": {
        return 3;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const SinQuality = {
  SIN_QUALITY_UNSPECIFIED: "SIN_QUALITY_UNSPECIFIED",
  SIN_QUALITY_LEVEL_1: "SIN_QUALITY_LEVEL_1",
  SIN_QUALITY_LEVEL_2: "SIN_QUALITY_LEVEL_2",
  SIN_QUALITY_LEVEL_3: "SIN_QUALITY_LEVEL_3",
  SIN_QUALITY_LEVEL_4: "SIN_QUALITY_LEVEL_4",
  SIN_QUALITY_LEVEL_5: "SIN_QUALITY_LEVEL_5",
  SIN_QUALITY_LEVEL_6: "SIN_QUALITY_LEVEL_6",
  /**
   * @private
   */
  _fromInt: function (i: number): SinQuality {
    switch (i) {
      case 0: {
        return "SIN_QUALITY_UNSPECIFIED";
      }
      case 1: {
        return "SIN_QUALITY_LEVEL_1";
      }
      case 2: {
        return "SIN_QUALITY_LEVEL_2";
      }
      case 3: {
        return "SIN_QUALITY_LEVEL_3";
      }
      case 4: {
        return "SIN_QUALITY_LEVEL_4";
      }
      case 5: {
        return "SIN_QUALITY_LEVEL_5";
      }
      case 6: {
        return "SIN_QUALITY_LEVEL_6";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as SinQuality;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: SinQuality): number {
    switch (i) {
      case "SIN_QUALITY_UNSPECIFIED": {
        return 0;
      }
      case "SIN_QUALITY_LEVEL_1": {
        return 1;
      }
      case "SIN_QUALITY_LEVEL_2": {
        return 2;
      }
      case "SIN_QUALITY_LEVEL_3": {
        return 3;
      }
      case "SIN_QUALITY_LEVEL_4": {
        return 4;
      }
      case "SIN_QUALITY_LEVEL_5": {
        return 5;
      }
      case "SIN_QUALITY_LEVEL_6": {
        return 6;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const BloodType = {
  BLOOD_TYPE_UNSPECIFIED: "BLOOD_TYPE_UNSPECIFIED",
  BLOOD_TYPE_A_POSITIVE: "BLOOD_TYPE_A_POSITIVE",
  BLOOD_TYPE_A_NEGATIVE: "BLOOD_TYPE_A_NEGATIVE",
  BLOOD_TYPE_B_POSITIVE: "BLOOD_TYPE_B_POSITIVE",
  BLOOD_TYPE_B_NEGATIVE: "BLOOD_TYPE_B_NEGATIVE",
  BLOOD_TYPE_AB_POSITIVE: "BLOOD_TYPE_AB_POSITIVE",
  BLOOD_TYPE_AB_NEGATIVE: "BLOOD_TYPE_AB_NEGATIVE",
  BLOOD_TYPE_O_POSITIVE: "BLOOD_TYPE_O_POSITIVE",
  BLOOD_TYPE_O_NEGATIVE: "BLOOD_TYPE_O_NEGATIVE",
  /**
   * @private
   */
  _fromInt: function (i: number): BloodType {
    switch (i) {
      case 0: {
        return "BLOOD_TYPE_UNSPECIFIED";
      }
      case 1: {
        return "BLOOD_TYPE_A_POSITIVE";
      }
      case 2: {
        return "BLOOD_TYPE_A_NEGATIVE";
      }
      case 3: {
        return "BLOOD_TYPE_B_POSITIVE";
      }
      case 4: {
        return "BLOOD_TYPE_B_NEGATIVE";
      }
      case 5: {
        return "BLOOD_TYPE_AB_POSITIVE";
      }
      case 6: {
        return "BLOOD_TYPE_AB_NEGATIVE";
      }
      case 7: {
        return "BLOOD_TYPE_O_POSITIVE";
      }
      case 8: {
        return "BLOOD_TYPE_O_NEGATIVE";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as BloodType;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: BloodType): number {
    switch (i) {
      case "BLOOD_TYPE_UNSPECIFIED": {
        return 0;
      }
      case "BLOOD_TYPE_A_POSITIVE": {
        return 1;
      }
      case "BLOOD_TYPE_A_NEGATIVE": {
        return 2;
      }
      case "BLOOD_TYPE_B_POSITIVE": {
        return 3;
      }
      case "BLOOD_TYPE_B_NEGATIVE": {
        return 4;
      }
      case "BLOOD_TYPE_AB_POSITIVE": {
        return 5;
      }
      case "BLOOD_TYPE_AB_NEGATIVE": {
        return 6;
      }
      case "BLOOD_TYPE_O_POSITIVE": {
        return 7;
      }
      case "BLOOD_TYPE_O_NEGATIVE": {
        return 8;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const SinLevel1 = {
  /**
   * Serializes SinLevel1 to protobuf.
   */
  encode: function (msg: PartialDeep<SinLevel1>): Uint8Array {
    return SinLevel1._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes SinLevel1 from protobuf.
   */
  decode: function (bytes: ByteSource): SinLevel1 {
    return SinLevel1._readMessage(
      SinLevel1.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes SinLevel1 with all fields set to their default value.
   */
  initialize: function (msg?: Partial<SinLevel1>): SinLevel1 {
    return {
      photo: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<SinLevel1>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.photo) {
      writer.writeString(1, msg.photo);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SinLevel1,
    reader: protoscript.BinaryReader,
  ): SinLevel1 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.photo = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const SinLevel2 = {
  /**
   * Serializes SinLevel2 to protobuf.
   */
  encode: function (msg: PartialDeep<SinLevel2>): Uint8Array {
    return SinLevel2._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes SinLevel2 from protobuf.
   */
  decode: function (bytes: ByteSource): SinLevel2 {
    return SinLevel2._readMessage(
      SinLevel2.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes SinLevel2 with all fields set to their default value.
   */
  initialize: function (msg?: Partial<SinLevel2>): SinLevel2 {
    return {
      name: "",
      birthdate: "",
      birthplace: "",
      gender: Gender._fromInt(0),
      metatype: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<SinLevel2>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.birthdate) {
      writer.writeString(2, msg.birthdate);
    }
    if (msg.birthplace) {
      writer.writeString(3, msg.birthplace);
    }
    if (msg.gender && Gender._toInt(msg.gender)) {
      writer.writeEnum(4, Gender._toInt(msg.gender));
    }
    if (msg.metatype) {
      writer.writeString(5, msg.metatype);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SinLevel2,
    reader: protoscript.BinaryReader,
  ): SinLevel2 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          msg.birthdate = reader.readString();
          break;
        }
        case 3: {
          msg.birthplace = reader.readString();
          break;
        }
        case 4: {
          msg.gender = Gender._fromInt(reader.readEnum());
          break;
        }
        case 5: {
          msg.metatype = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const SinLevel3 = {
  /**
   * Serializes SinLevel3 to protobuf.
   */
  encode: function (msg: PartialDeep<SinLevel3>): Uint8Array {
    return SinLevel3._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes SinLevel3 from protobuf.
   */
  decode: function (bytes: ByteSource): SinLevel3 {
    return SinLevel3._readMessage(
      SinLevel3.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes SinLevel3 with all fields set to their default value.
   */
  initialize: function (msg?: Partial<SinLevel3>): SinLevel3 {
    return {
      fullName: "",
      address: "",
      city: "",
      country: "",
      nationality: "",
      occupation: "",
      datalinks: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<SinLevel3>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.fullName) {
      writer.writeString(1, msg.fullName);
    }
    if (msg.address) {
      writer.writeString(2, msg.address);
    }
    if (msg.city) {
      writer.writeString(3, msg.city);
    }
    if (msg.country) {
      writer.writeString(4, msg.country);
    }
    if (msg.nationality) {
      writer.writeString(5, msg.nationality);
    }
    if (msg.occupation) {
      writer.writeString(6, msg.occupation);
    }
    if (msg.datalinks?.length) {
      writer.writeRepeatedString(7, msg.datalinks);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SinLevel3,
    reader: protoscript.BinaryReader,
  ): SinLevel3 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fullName = reader.readString();
          break;
        }
        case 2: {
          msg.address = reader.readString();
          break;
        }
        case 3: {
          msg.city = reader.readString();
          break;
        }
        case 4: {
          msg.country = reader.readString();
          break;
        }
        case 5: {
          msg.nationality = reader.readString();
          break;
        }
        case 6: {
          msg.occupation = reader.readString();
          break;
        }
        case 7: {
          msg.datalinks.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const SinLevel4 = {
  /**
   * Serializes SinLevel4 to protobuf.
   */
  encode: function (msg: PartialDeep<SinLevel4>): Uint8Array {
    return SinLevel4._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes SinLevel4 from protobuf.
   */
  decode: function (bytes: ByteSource): SinLevel4 {
    return SinLevel4._readMessage(
      SinLevel4.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes SinLevel4 with all fields set to their default value.
   */
  initialize: function (msg?: Partial<SinLevel4>): SinLevel4 {
    return {
      fingerprintHash: "",
      retinalHash: "",
      voiceHash: "",
      height: 0,
      weight: 0,
      eyeColor: "",
      hairColor: "",
      skinTone: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<SinLevel4>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.fingerprintHash) {
      writer.writeString(1, msg.fingerprintHash);
    }
    if (msg.retinalHash) {
      writer.writeString(2, msg.retinalHash);
    }
    if (msg.voiceHash) {
      writer.writeString(3, msg.voiceHash);
    }
    if (msg.height) {
      writer.writeInt32(4, msg.height);
    }
    if (msg.weight) {
      writer.writeInt32(5, msg.weight);
    }
    if (msg.eyeColor) {
      writer.writeString(6, msg.eyeColor);
    }
    if (msg.hairColor) {
      writer.writeString(7, msg.hairColor);
    }
    if (msg.skinTone) {
      writer.writeString(8, msg.skinTone);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SinLevel4,
    reader: protoscript.BinaryReader,
  ): SinLevel4 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fingerprintHash = reader.readString();
          break;
        }
        case 2: {
          msg.retinalHash = reader.readString();
          break;
        }
        case 3: {
          msg.voiceHash = reader.readString();
          break;
        }
        case 4: {
          msg.height = reader.readInt32();
          break;
        }
        case 5: {
          msg.weight = reader.readInt32();
          break;
        }
        case 6: {
          msg.eyeColor = reader.readString();
          break;
        }
        case 7: {
          msg.hairColor = reader.readString();
          break;
        }
        case 8: {
          msg.skinTone = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const SinLevel5 = {
  /**
   * Serializes SinLevel5 to protobuf.
   */
  encode: function (msg: PartialDeep<SinLevel5>): Uint8Array {
    return SinLevel5._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes SinLevel5 from protobuf.
   */
  decode: function (bytes: ByteSource): SinLevel5 {
    return SinLevel5._readMessage(
      SinLevel5.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes SinLevel5 with all fields set to their default value.
   */
  initialize: function (msg?: Partial<SinLevel5>): SinLevel5 {
    return {
      employer: "",
      employerAddress: "",
      travelStamps: [],
      affiliationCodes: [],
      educationRecords: [],
      residenceHistory: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<SinLevel5>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.employer) {
      writer.writeString(1, msg.employer);
    }
    if (msg.employerAddress) {
      writer.writeString(2, msg.employerAddress);
    }
    if (msg.travelStamps?.length) {
      writer.writeRepeatedString(3, msg.travelStamps);
    }
    if (msg.affiliationCodes?.length) {
      writer.writeRepeatedString(4, msg.affiliationCodes);
    }
    if (msg.educationRecords?.length) {
      writer.writeRepeatedString(5, msg.educationRecords);
    }
    if (msg.residenceHistory?.length) {
      writer.writeRepeatedString(6, msg.residenceHistory);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SinLevel5,
    reader: protoscript.BinaryReader,
  ): SinLevel5 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.employer = reader.readString();
          break;
        }
        case 2: {
          msg.employerAddress = reader.readString();
          break;
        }
        case 3: {
          msg.travelStamps.push(reader.readString());
          break;
        }
        case 4: {
          msg.affiliationCodes.push(reader.readString());
          break;
        }
        case 5: {
          msg.educationRecords.push(reader.readString());
          break;
        }
        case 6: {
          msg.residenceHistory.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const SinLevel6 = {
  /**
   * Serializes SinLevel6 to protobuf.
   */
  encode: function (msg: PartialDeep<SinLevel6>): Uint8Array {
    return SinLevel6._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes SinLevel6 from protobuf.
   */
  decode: function (bytes: ByteSource): SinLevel6 {
    return SinLevel6._readMessage(
      SinLevel6.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes SinLevel6 with all fields set to their default value.
   */
  initialize: function (msg?: Partial<SinLevel6>): SinLevel6 {
    return {
      bloodType: BloodType._fromInt(0),
      dnaSequenceHash: "",
      geneticMarkers: [],
      medicalAlertCodes: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<SinLevel6>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.bloodType && BloodType._toInt(msg.bloodType)) {
      writer.writeEnum(1, BloodType._toInt(msg.bloodType));
    }
    if (msg.dnaSequenceHash) {
      writer.writeString(2, msg.dnaSequenceHash);
    }
    if (msg.geneticMarkers?.length) {
      writer.writeRepeatedString(3, msg.geneticMarkers);
    }
    if (msg.medicalAlertCodes) {
      writer.writeString(4, msg.medicalAlertCodes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SinLevel6,
    reader: protoscript.BinaryReader,
  ): SinLevel6 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.bloodType = BloodType._fromInt(reader.readEnum());
          break;
        }
        case 2: {
          msg.dnaSequenceHash = reader.readString();
          break;
        }
        case 3: {
          msg.geneticMarkers.push(reader.readString());
          break;
        }
        case 4: {
          msg.medicalAlertCodes = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ProfileData = {
  /**
   * Serializes ProfileData to protobuf.
   */
  encode: function (msg: PartialDeep<ProfileData>): Uint8Array {
    return ProfileData._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ProfileData from protobuf.
   */
  decode: function (bytes: ByteSource): ProfileData {
    return ProfileData._readMessage(
      ProfileData.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes ProfileData with all fields set to their default value.
   */
  initialize: function (msg?: Partial<ProfileData>): ProfileData {
    return {
      sinId: "",
      active: false,
      sinQuality: SinQuality._fromInt(0),
      licenses: {},
      level1: undefined,
      level2: undefined,
      level3: undefined,
      level4: undefined,
      level5: undefined,
      level6: undefined,
      baseSeed: 0,
      biometricSeed: 0,
      backgroundSeed: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ProfileData>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.sinId) {
      writer.writeString(1, msg.sinId);
    }
    if (msg.active) {
      writer.writeBool(2, msg.active);
    }
    if (msg.sinQuality && SinQuality._toInt(msg.sinQuality)) {
      writer.writeEnum(3, SinQuality._toInt(msg.sinQuality));
    }
    if (msg.licenses) {
      writer.writeRepeatedMessage(
        4,
        Object.entries(msg.licenses).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        ProfileData.Licenses._writeMessage,
      );
    }
    if (msg.level1 != undefined) {
      writer.writeMessage(5, msg.level1, SinLevel1._writeMessage);
    }
    if (msg.level2 != undefined) {
      writer.writeMessage(6, msg.level2, SinLevel2._writeMessage);
    }
    if (msg.level3 != undefined) {
      writer.writeMessage(7, msg.level3, SinLevel3._writeMessage);
    }
    if (msg.level4 != undefined) {
      writer.writeMessage(8, msg.level4, SinLevel4._writeMessage);
    }
    if (msg.level5 != undefined) {
      writer.writeMessage(9, msg.level5, SinLevel5._writeMessage);
    }
    if (msg.level6 != undefined) {
      writer.writeMessage(10, msg.level6, SinLevel6._writeMessage);
    }
    if (msg.baseSeed) {
      writer.writeInt32(11, msg.baseSeed);
    }
    if (msg.biometricSeed) {
      writer.writeInt32(12, msg.biometricSeed);
    }
    if (msg.backgroundSeed) {
      writer.writeInt32(13, msg.backgroundSeed);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ProfileData,
    reader: protoscript.BinaryReader,
  ): ProfileData {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sinId = reader.readString();
          break;
        }
        case 2: {
          msg.active = reader.readBool();
          break;
        }
        case 3: {
          msg.sinQuality = SinQuality._fromInt(reader.readEnum());
          break;
        }
        case 4: {
          const map = {} as ProfileData.Licenses;
          reader.readMessage(map, ProfileData.Licenses._readMessage);
          msg.licenses[map.key.toString()] = map.value;
          break;
        }
        case 5: {
          msg.level1 = SinLevel1.initialize();
          reader.readMessage(msg.level1, SinLevel1._readMessage);
          break;
        }
        case 6: {
          msg.level2 = SinLevel2.initialize();
          reader.readMessage(msg.level2, SinLevel2._readMessage);
          break;
        }
        case 7: {
          msg.level3 = SinLevel3.initialize();
          reader.readMessage(msg.level3, SinLevel3._readMessage);
          break;
        }
        case 8: {
          msg.level4 = SinLevel4.initialize();
          reader.readMessage(msg.level4, SinLevel4._readMessage);
          break;
        }
        case 9: {
          msg.level5 = SinLevel5.initialize();
          reader.readMessage(msg.level5, SinLevel5._readMessage);
          break;
        }
        case 10: {
          msg.level6 = SinLevel6.initialize();
          reader.readMessage(msg.level6, SinLevel6._readMessage);
          break;
        }
        case 11: {
          msg.baseSeed = reader.readInt32();
          break;
        }
        case 12: {
          msg.biometricSeed = reader.readInt32();
          break;
        }
        case 13: {
          msg.backgroundSeed = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Licenses: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<ProfileData.Licenses>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value && SinQuality._toInt(msg.value)) {
        writer.writeEnum(2, SinQuality._toInt(msg.value));
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: ProfileData.Licenses,
      reader: protoscript.BinaryReader,
    ): ProfileData.Licenses {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = SinQuality._fromInt(reader.readEnum());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const GenderJSON = {
  GENDER_UNSPECIFIED: "GENDER_UNSPECIFIED",
  GENDER_MALE: "GENDER_MALE",
  GENDER_FEMALE: "GENDER_FEMALE",
  GENDER_DIVERSE: "GENDER_DIVERSE",
  /**
   * @private
   */
  _fromInt: function (i: number): Gender {
    switch (i) {
      case 0: {
        return "GENDER_UNSPECIFIED";
      }
      case 1: {
        return "GENDER_MALE";
      }
      case 2: {
        return "GENDER_FEMALE";
      }
      case 3: {
        return "GENDER_DIVERSE";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as Gender;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: Gender): number {
    switch (i) {
      case "GENDER_UNSPECIFIED": {
        return 0;
      }
      case "GENDER_MALE": {
        return 1;
      }
      case "GENDER_FEMALE": {
        return 2;
      }
      case "GENDER_DIVERSE": {
        return 3;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const SinQualityJSON = {
  SIN_QUALITY_UNSPECIFIED: "SIN_QUALITY_UNSPECIFIED",
  SIN_QUALITY_LEVEL_1: "SIN_QUALITY_LEVEL_1",
  SIN_QUALITY_LEVEL_2: "SIN_QUALITY_LEVEL_2",
  SIN_QUALITY_LEVEL_3: "SIN_QUALITY_LEVEL_3",
  SIN_QUALITY_LEVEL_4: "SIN_QUALITY_LEVEL_4",
  SIN_QUALITY_LEVEL_5: "SIN_QUALITY_LEVEL_5",
  SIN_QUALITY_LEVEL_6: "SIN_QUALITY_LEVEL_6",
  /**
   * @private
   */
  _fromInt: function (i: number): SinQuality {
    switch (i) {
      case 0: {
        return "SIN_QUALITY_UNSPECIFIED";
      }
      case 1: {
        return "SIN_QUALITY_LEVEL_1";
      }
      case 2: {
        return "SIN_QUALITY_LEVEL_2";
      }
      case 3: {
        return "SIN_QUALITY_LEVEL_3";
      }
      case 4: {
        return "SIN_QUALITY_LEVEL_4";
      }
      case 5: {
        return "SIN_QUALITY_LEVEL_5";
      }
      case 6: {
        return "SIN_QUALITY_LEVEL_6";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as SinQuality;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: SinQuality): number {
    switch (i) {
      case "SIN_QUALITY_UNSPECIFIED": {
        return 0;
      }
      case "SIN_QUALITY_LEVEL_1": {
        return 1;
      }
      case "SIN_QUALITY_LEVEL_2": {
        return 2;
      }
      case "SIN_QUALITY_LEVEL_3": {
        return 3;
      }
      case "SIN_QUALITY_LEVEL_4": {
        return 4;
      }
      case "SIN_QUALITY_LEVEL_5": {
        return 5;
      }
      case "SIN_QUALITY_LEVEL_6": {
        return 6;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const BloodTypeJSON = {
  BLOOD_TYPE_UNSPECIFIED: "BLOOD_TYPE_UNSPECIFIED",
  BLOOD_TYPE_A_POSITIVE: "BLOOD_TYPE_A_POSITIVE",
  BLOOD_TYPE_A_NEGATIVE: "BLOOD_TYPE_A_NEGATIVE",
  BLOOD_TYPE_B_POSITIVE: "BLOOD_TYPE_B_POSITIVE",
  BLOOD_TYPE_B_NEGATIVE: "BLOOD_TYPE_B_NEGATIVE",
  BLOOD_TYPE_AB_POSITIVE: "BLOOD_TYPE_AB_POSITIVE",
  BLOOD_TYPE_AB_NEGATIVE: "BLOOD_TYPE_AB_NEGATIVE",
  BLOOD_TYPE_O_POSITIVE: "BLOOD_TYPE_O_POSITIVE",
  BLOOD_TYPE_O_NEGATIVE: "BLOOD_TYPE_O_NEGATIVE",
  /**
   * @private
   */
  _fromInt: function (i: number): BloodType {
    switch (i) {
      case 0: {
        return "BLOOD_TYPE_UNSPECIFIED";
      }
      case 1: {
        return "BLOOD_TYPE_A_POSITIVE";
      }
      case 2: {
        return "BLOOD_TYPE_A_NEGATIVE";
      }
      case 3: {
        return "BLOOD_TYPE_B_POSITIVE";
      }
      case 4: {
        return "BLOOD_TYPE_B_NEGATIVE";
      }
      case 5: {
        return "BLOOD_TYPE_AB_POSITIVE";
      }
      case 6: {
        return "BLOOD_TYPE_AB_NEGATIVE";
      }
      case 7: {
        return "BLOOD_TYPE_O_POSITIVE";
      }
      case 8: {
        return "BLOOD_TYPE_O_NEGATIVE";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as BloodType;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: BloodType): number {
    switch (i) {
      case "BLOOD_TYPE_UNSPECIFIED": {
        return 0;
      }
      case "BLOOD_TYPE_A_POSITIVE": {
        return 1;
      }
      case "BLOOD_TYPE_A_NEGATIVE": {
        return 2;
      }
      case "BLOOD_TYPE_B_POSITIVE": {
        return 3;
      }
      case "BLOOD_TYPE_B_NEGATIVE": {
        return 4;
      }
      case "BLOOD_TYPE_AB_POSITIVE": {
        return 5;
      }
      case "BLOOD_TYPE_AB_NEGATIVE": {
        return 6;
      }
      case "BLOOD_TYPE_O_POSITIVE": {
        return 7;
      }
      case "BLOOD_TYPE_O_NEGATIVE": {
        return 8;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const SinLevel1JSON = {
  /**
   * Serializes SinLevel1 to JSON.
   */
  encode: function (msg: PartialDeep<SinLevel1>): string {
    return JSON.stringify(SinLevel1JSON._writeMessage(msg));
  },

  /**
   * Deserializes SinLevel1 from JSON.
   */
  decode: function (json: string): SinLevel1 {
    return SinLevel1JSON._readMessage(
      SinLevel1JSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes SinLevel1 with all fields set to their default value.
   */
  initialize: function (msg?: Partial<SinLevel1>): SinLevel1 {
    return {
      photo: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<SinLevel1>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.photo) {
      json["photo"] = msg.photo;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: SinLevel1, json: any): SinLevel1 {
    const _photo_ = json["photo"];
    if (_photo_) {
      msg.photo = _photo_;
    }
    return msg;
  },
};

export const SinLevel2JSON = {
  /**
   * Serializes SinLevel2 to JSON.
   */
  encode: function (msg: PartialDeep<SinLevel2>): string {
    return JSON.stringify(SinLevel2JSON._writeMessage(msg));
  },

  /**
   * Deserializes SinLevel2 from JSON.
   */
  decode: function (json: string): SinLevel2 {
    return SinLevel2JSON._readMessage(
      SinLevel2JSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes SinLevel2 with all fields set to their default value.
   */
  initialize: function (msg?: Partial<SinLevel2>): SinLevel2 {
    return {
      name: "",
      birthdate: "",
      birthplace: "",
      gender: Gender._fromInt(0),
      metatype: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<SinLevel2>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.birthdate) {
      json["birthdate"] = msg.birthdate;
    }
    if (msg.birthplace) {
      json["birthplace"] = msg.birthplace;
    }
    if (msg.gender && GenderJSON._toInt(msg.gender)) {
      json["gender"] = msg.gender;
    }
    if (msg.metatype) {
      json["metatype"] = msg.metatype;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: SinLevel2, json: any): SinLevel2 {
    const _name_ = json["name"];
    if (_name_) {
      msg.name = _name_;
    }
    const _birthdate_ = json["birthdate"];
    if (_birthdate_) {
      msg.birthdate = _birthdate_;
    }
    const _birthplace_ = json["birthplace"];
    if (_birthplace_) {
      msg.birthplace = _birthplace_;
    }
    const _gender_ = json["gender"];
    if (_gender_) {
      msg.gender = Gender._fromInt(_gender_);
    }
    const _metatype_ = json["metatype"];
    if (_metatype_) {
      msg.metatype = _metatype_;
    }
    return msg;
  },
};

export const SinLevel3JSON = {
  /**
   * Serializes SinLevel3 to JSON.
   */
  encode: function (msg: PartialDeep<SinLevel3>): string {
    return JSON.stringify(SinLevel3JSON._writeMessage(msg));
  },

  /**
   * Deserializes SinLevel3 from JSON.
   */
  decode: function (json: string): SinLevel3 {
    return SinLevel3JSON._readMessage(
      SinLevel3JSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes SinLevel3 with all fields set to their default value.
   */
  initialize: function (msg?: Partial<SinLevel3>): SinLevel3 {
    return {
      fullName: "",
      address: "",
      city: "",
      country: "",
      nationality: "",
      occupation: "",
      datalinks: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<SinLevel3>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fullName) {
      json["fullName"] = msg.fullName;
    }
    if (msg.address) {
      json["address"] = msg.address;
    }
    if (msg.city) {
      json["city"] = msg.city;
    }
    if (msg.country) {
      json["country"] = msg.country;
    }
    if (msg.nationality) {
      json["nationality"] = msg.nationality;
    }
    if (msg.occupation) {
      json["occupation"] = msg.occupation;
    }
    if (msg.datalinks?.length) {
      json["datalinks"] = msg.datalinks;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: SinLevel3, json: any): SinLevel3 {
    const _fullName_ = json["fullName"] ?? json["full_name"];
    if (_fullName_) {
      msg.fullName = _fullName_;
    }
    const _address_ = json["address"];
    if (_address_) {
      msg.address = _address_;
    }
    const _city_ = json["city"];
    if (_city_) {
      msg.city = _city_;
    }
    const _country_ = json["country"];
    if (_country_) {
      msg.country = _country_;
    }
    const _nationality_ = json["nationality"];
    if (_nationality_) {
      msg.nationality = _nationality_;
    }
    const _occupation_ = json["occupation"];
    if (_occupation_) {
      msg.occupation = _occupation_;
    }
    const _datalinks_ = json["datalinks"];
    if (_datalinks_) {
      msg.datalinks = _datalinks_;
    }
    return msg;
  },
};

export const SinLevel4JSON = {
  /**
   * Serializes SinLevel4 to JSON.
   */
  encode: function (msg: PartialDeep<SinLevel4>): string {
    return JSON.stringify(SinLevel4JSON._writeMessage(msg));
  },

  /**
   * Deserializes SinLevel4 from JSON.
   */
  decode: function (json: string): SinLevel4 {
    return SinLevel4JSON._readMessage(
      SinLevel4JSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes SinLevel4 with all fields set to their default value.
   */
  initialize: function (msg?: Partial<SinLevel4>): SinLevel4 {
    return {
      fingerprintHash: "",
      retinalHash: "",
      voiceHash: "",
      height: 0,
      weight: 0,
      eyeColor: "",
      hairColor: "",
      skinTone: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<SinLevel4>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fingerprintHash) {
      json["fingerprintHash"] = msg.fingerprintHash;
    }
    if (msg.retinalHash) {
      json["retinalHash"] = msg.retinalHash;
    }
    if (msg.voiceHash) {
      json["voiceHash"] = msg.voiceHash;
    }
    if (msg.height) {
      json["height"] = msg.height;
    }
    if (msg.weight) {
      json["weight"] = msg.weight;
    }
    if (msg.eyeColor) {
      json["eyeColor"] = msg.eyeColor;
    }
    if (msg.hairColor) {
      json["hairColor"] = msg.hairColor;
    }
    if (msg.skinTone) {
      json["skinTone"] = msg.skinTone;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: SinLevel4, json: any): SinLevel4 {
    const _fingerprintHash_ =
      json["fingerprintHash"] ?? json["fingerprint_hash"];
    if (_fingerprintHash_) {
      msg.fingerprintHash = _fingerprintHash_;
    }
    const _retinalHash_ = json["retinalHash"] ?? json["retinal_hash"];
    if (_retinalHash_) {
      msg.retinalHash = _retinalHash_;
    }
    const _voiceHash_ = json["voiceHash"] ?? json["voice_hash"];
    if (_voiceHash_) {
      msg.voiceHash = _voiceHash_;
    }
    const _height_ = json["height"];
    if (_height_) {
      msg.height = protoscript.parseNumber(_height_);
    }
    const _weight_ = json["weight"];
    if (_weight_) {
      msg.weight = protoscript.parseNumber(_weight_);
    }
    const _eyeColor_ = json["eyeColor"] ?? json["eye_color"];
    if (_eyeColor_) {
      msg.eyeColor = _eyeColor_;
    }
    const _hairColor_ = json["hairColor"] ?? json["hair_color"];
    if (_hairColor_) {
      msg.hairColor = _hairColor_;
    }
    const _skinTone_ = json["skinTone"] ?? json["skin_tone"];
    if (_skinTone_) {
      msg.skinTone = _skinTone_;
    }
    return msg;
  },
};

export const SinLevel5JSON = {
  /**
   * Serializes SinLevel5 to JSON.
   */
  encode: function (msg: PartialDeep<SinLevel5>): string {
    return JSON.stringify(SinLevel5JSON._writeMessage(msg));
  },

  /**
   * Deserializes SinLevel5 from JSON.
   */
  decode: function (json: string): SinLevel5 {
    return SinLevel5JSON._readMessage(
      SinLevel5JSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes SinLevel5 with all fields set to their default value.
   */
  initialize: function (msg?: Partial<SinLevel5>): SinLevel5 {
    return {
      employer: "",
      employerAddress: "",
      travelStamps: [],
      affiliationCodes: [],
      educationRecords: [],
      residenceHistory: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<SinLevel5>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.employer) {
      json["employer"] = msg.employer;
    }
    if (msg.employerAddress) {
      json["employerAddress"] = msg.employerAddress;
    }
    if (msg.travelStamps?.length) {
      json["travelStamps"] = msg.travelStamps;
    }
    if (msg.affiliationCodes?.length) {
      json["affiliationCodes"] = msg.affiliationCodes;
    }
    if (msg.educationRecords?.length) {
      json["educationRecords"] = msg.educationRecords;
    }
    if (msg.residenceHistory?.length) {
      json["residenceHistory"] = msg.residenceHistory;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: SinLevel5, json: any): SinLevel5 {
    const _employer_ = json["employer"];
    if (_employer_) {
      msg.employer = _employer_;
    }
    const _employerAddress_ =
      json["employerAddress"] ?? json["employer_address"];
    if (_employerAddress_) {
      msg.employerAddress = _employerAddress_;
    }
    const _travelStamps_ = json["travelStamps"] ?? json["travel_stamps"];
    if (_travelStamps_) {
      msg.travelStamps = _travelStamps_;
    }
    const _affiliationCodes_ =
      json["affiliationCodes"] ?? json["affiliation_codes"];
    if (_affiliationCodes_) {
      msg.affiliationCodes = _affiliationCodes_;
    }
    const _educationRecords_ =
      json["educationRecords"] ?? json["education_records"];
    if (_educationRecords_) {
      msg.educationRecords = _educationRecords_;
    }
    const _residenceHistory_ =
      json["residenceHistory"] ?? json["residence_history"];
    if (_residenceHistory_) {
      msg.residenceHistory = _residenceHistory_;
    }
    return msg;
  },
};

export const SinLevel6JSON = {
  /**
   * Serializes SinLevel6 to JSON.
   */
  encode: function (msg: PartialDeep<SinLevel6>): string {
    return JSON.stringify(SinLevel6JSON._writeMessage(msg));
  },

  /**
   * Deserializes SinLevel6 from JSON.
   */
  decode: function (json: string): SinLevel6 {
    return SinLevel6JSON._readMessage(
      SinLevel6JSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes SinLevel6 with all fields set to their default value.
   */
  initialize: function (msg?: Partial<SinLevel6>): SinLevel6 {
    return {
      bloodType: BloodType._fromInt(0),
      dnaSequenceHash: "",
      geneticMarkers: [],
      medicalAlertCodes: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<SinLevel6>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.bloodType && BloodTypeJSON._toInt(msg.bloodType)) {
      json["bloodType"] = msg.bloodType;
    }
    if (msg.dnaSequenceHash) {
      json["dnaSequenceHash"] = msg.dnaSequenceHash;
    }
    if (msg.geneticMarkers?.length) {
      json["geneticMarkers"] = msg.geneticMarkers;
    }
    if (msg.medicalAlertCodes) {
      json["medicalAlertCodes"] = msg.medicalAlertCodes;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: SinLevel6, json: any): SinLevel6 {
    const _bloodType_ = json["bloodType"] ?? json["blood_type"];
    if (_bloodType_) {
      msg.bloodType = BloodType._fromInt(_bloodType_);
    }
    const _dnaSequenceHash_ =
      json["dnaSequenceHash"] ?? json["dna_sequence_hash"];
    if (_dnaSequenceHash_) {
      msg.dnaSequenceHash = _dnaSequenceHash_;
    }
    const _geneticMarkers_ = json["geneticMarkers"] ?? json["genetic_markers"];
    if (_geneticMarkers_) {
      msg.geneticMarkers = _geneticMarkers_;
    }
    const _medicalAlertCodes_ =
      json["medicalAlertCodes"] ?? json["medical_alert_codes"];
    if (_medicalAlertCodes_) {
      msg.medicalAlertCodes = _medicalAlertCodes_;
    }
    return msg;
  },
};

export const ProfileDataJSON = {
  /**
   * Serializes ProfileData to JSON.
   */
  encode: function (msg: PartialDeep<ProfileData>): string {
    return JSON.stringify(ProfileDataJSON._writeMessage(msg));
  },

  /**
   * Deserializes ProfileData from JSON.
   */
  decode: function (json: string): ProfileData {
    return ProfileDataJSON._readMessage(
      ProfileDataJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ProfileData with all fields set to their default value.
   */
  initialize: function (msg?: Partial<ProfileData>): ProfileData {
    return {
      sinId: "",
      active: false,
      sinQuality: SinQuality._fromInt(0),
      licenses: {},
      level1: undefined,
      level2: undefined,
      level3: undefined,
      level4: undefined,
      level5: undefined,
      level6: undefined,
      baseSeed: 0,
      biometricSeed: 0,
      backgroundSeed: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ProfileData>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.sinId) {
      json["sinId"] = msg.sinId;
    }
    if (msg.active) {
      json["active"] = msg.active;
    }
    if (msg.sinQuality && SinQualityJSON._toInt(msg.sinQuality)) {
      json["sinQuality"] = msg.sinQuality;
    }
    if (msg.licenses) {
      const _licenses_ = Object.fromEntries(
        Object.entries(msg.licenses)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(ProfileDataJSON.Licenses._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_licenses_).length > 0) {
        json["licenses"] = _licenses_;
      }
    }
    if (msg.level1 != undefined) {
      const _level1_ = SinLevel1JSON._writeMessage(msg.level1);
      json["level1"] = _level1_;
    }
    if (msg.level2 != undefined) {
      const _level2_ = SinLevel2JSON._writeMessage(msg.level2);
      json["level2"] = _level2_;
    }
    if (msg.level3 != undefined) {
      const _level3_ = SinLevel3JSON._writeMessage(msg.level3);
      json["level3"] = _level3_;
    }
    if (msg.level4 != undefined) {
      const _level4_ = SinLevel4JSON._writeMessage(msg.level4);
      json["level4"] = _level4_;
    }
    if (msg.level5 != undefined) {
      const _level5_ = SinLevel5JSON._writeMessage(msg.level5);
      json["level5"] = _level5_;
    }
    if (msg.level6 != undefined) {
      const _level6_ = SinLevel6JSON._writeMessage(msg.level6);
      json["level6"] = _level6_;
    }
    if (msg.baseSeed) {
      json["baseSeed"] = msg.baseSeed;
    }
    if (msg.biometricSeed) {
      json["biometricSeed"] = msg.biometricSeed;
    }
    if (msg.backgroundSeed) {
      json["backgroundSeed"] = msg.backgroundSeed;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: ProfileData, json: any): ProfileData {
    const _sinId_ = json["sinId"] ?? json["sin_id"];
    if (_sinId_) {
      msg.sinId = _sinId_;
    }
    const _active_ = json["active"];
    if (_active_) {
      msg.active = _active_;
    }
    const _sinQuality_ = json["sinQuality"] ?? json["sin_quality"];
    if (_sinQuality_) {
      msg.sinQuality = SinQuality._fromInt(_sinQuality_);
    }
    const _licenses_ = json["licenses"];
    if (_licenses_) {
      msg.licenses = Object.fromEntries(
        Object.entries(_licenses_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(ProfileDataJSON.Licenses._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _level1_ = json["level1"];
    if (_level1_) {
      msg.level1 = SinLevel1JSON.initialize();
      SinLevel1JSON._readMessage(msg.level1, _level1_);
    }
    const _level2_ = json["level2"];
    if (_level2_) {
      msg.level2 = SinLevel2JSON.initialize();
      SinLevel2JSON._readMessage(msg.level2, _level2_);
    }
    const _level3_ = json["level3"];
    if (_level3_) {
      msg.level3 = SinLevel3JSON.initialize();
      SinLevel3JSON._readMessage(msg.level3, _level3_);
    }
    const _level4_ = json["level4"];
    if (_level4_) {
      msg.level4 = SinLevel4JSON.initialize();
      SinLevel4JSON._readMessage(msg.level4, _level4_);
    }
    const _level5_ = json["level5"];
    if (_level5_) {
      msg.level5 = SinLevel5JSON.initialize();
      SinLevel5JSON._readMessage(msg.level5, _level5_);
    }
    const _level6_ = json["level6"];
    if (_level6_) {
      msg.level6 = SinLevel6JSON.initialize();
      SinLevel6JSON._readMessage(msg.level6, _level6_);
    }
    const _baseSeed_ = json["baseSeed"] ?? json["base_seed"];
    if (_baseSeed_) {
      msg.baseSeed = protoscript.parseNumber(_baseSeed_);
    }
    const _biometricSeed_ = json["biometricSeed"] ?? json["biometric_seed"];
    if (_biometricSeed_) {
      msg.biometricSeed = protoscript.parseNumber(_biometricSeed_);
    }
    const _backgroundSeed_ = json["backgroundSeed"] ?? json["background_seed"];
    if (_backgroundSeed_) {
      msg.backgroundSeed = protoscript.parseNumber(_backgroundSeed_);
    }
    return msg;
  },

  Licenses: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<ProfileData.Licenses>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value && SinQualityJSON._toInt(msg.value)) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: ProfileData.Licenses,
      json: any,
    ): ProfileData.Licenses {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = SinQuality._fromInt(_value_);
      }
      return msg;
    },
  },
};
